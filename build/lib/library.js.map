{
  "version": 3,
  "sources": ["../../src/lib/library.ts"],
  "sourcesContent": ["import _fs from 'fs';\nimport type { statesObjectsType } from './definition';\n// eslint-disable-next-line\nimport { genericStateObjects } from './definition';\nimport type tagesschau from '../main';\n\n// only change this for other adapters\nexport type AdapterClassDefinition = tagesschau;\n\nexport type LibraryStateVal = LibraryStateValJson | undefined;\ntype LibraryStateValJson = {\n    type: ioBroker.ObjectType;\n    stateTyp: string | undefined;\n    val: ioBroker.StateValue | undefined;\n    ts: number;\n    ack: boolean;\n    obj: ioBroker.Object | undefined;\n    init: boolean;\n};\n\n// Generic library module and base classes, do not insert specific adapter code here.\n\n/**\n * Base class with this.log function\n */\nexport class BaseClass {\n    unload: boolean = false;\n    log: CustomLog;\n    adapter: AdapterClassDefinition;\n    library: Library;\n    name: string = ``;\n\n    /**\n     * Creates an instance of BaseClass.\n     *\n     * @param adapter The adapter instance.\n     * @param name The name of the class.\n     * @classdesc Base class for all classes.\n     * adapter The adapter instance.\n     * library The library instance.\n     * name The name of the class.\n     * log The log instance.\n     * unload The unload state.\n     * [options] The options for the class.\n     * @returns The base class instance.\n     */\n    constructor(adapter: AdapterClassDefinition, name: string = '') {\n        this.name = name;\n        this.log = new CustomLog(adapter, this.name);\n        this.adapter = adapter;\n        this.library = adapter.library;\n    }\n    /**\n     * Marks the library for unloading.\n     */\n    delete(): void {\n        this.unload = true;\n    }\n}\n\nclass CustomLog {\n    #adapter: AdapterClassDefinition;\n    #prefix: string;\n    constructor(adapter: AdapterClassDefinition, text: string = '') {\n        this.#adapter = adapter;\n        this.#prefix = text;\n    }\n    getName(): string {\n        return this.#prefix;\n    }\n    debug(log: string, log2: string = ''): void {\n        this.#adapter.log.debug(log2 ? `[${log}] ${log2}` : `[${this.#prefix}] ${log}`);\n    }\n    info(log: string, log2: string = ''): void {\n        this.#adapter.log.info(log2 ? `[${log}] ${log2}` : `[${this.#prefix}] ${log}`);\n    }\n    warn(log: string, log2: string = ''): void {\n        this.#adapter.log.warn(log2 ? `[${log}] ${log2}` : `[${this.#prefix}] ${log}`);\n    }\n    error(log: string, log2: string = ''): void {\n        this.#adapter.log.error(log2 ? `[${log}] ${log2}` : `[${this.#prefix}] ${log}`);\n    }\n    setLogPrefix(text: string): void {\n        this.#prefix = text;\n    }\n}\n/**\n * Library class for the adapter.\n */\nexport class Library extends BaseClass {\n    private stateDataBase: { [key: string]: LibraryStateVal } = {};\n    private language: ioBroker.Languages | 'uk' = 'en';\n    private translation: { [key: string]: string } = {};\n\n    /**\n     * use extendObject always on folder, devices and channels always\n     */\n    private extendedFolderAlways = false;\n\n    defaults = {\n        updateStateOnChangeOnly: true,\n    };\n    /**\n     * Creates an instance of Library.\n     *\n     * @param adapter The adapter instance.\n     * @param _options The options for the library.\n     */\n    constructor(adapter: AdapterClassDefinition, _options: any = null) {\n        super(adapter, 'library');\n        this.stateDataBase = {};\n    }\n    /**\n     * Initialise the library.\n     */\n    async init(): Promise<void> {\n        const obj = await this.adapter.getForeignObjectAsync('system.config');\n        if (obj) {\n            await this.setLanguage(obj.common.language, true);\n        } else {\n            await this.setLanguage('en', true);\n        }\n    }\n\n    /**\n     * Write/create from a Json with defined keys, the associated states and channels.\n     *\n     * @param prefix iobroker datapoint prefix where to write\n     * @param objNode Entry point into the definition json.\n     * @param def the definition json\n     * @param data The Json to read\n     * @param expandTree expand arrays up to 99\n     * @param onlyCreate only create the objects, do not write the values in exists states.\n     * @param isArray is the data from an array\n     * @returns  void\n     */\n    async writeFromJson(\n        // provider.dwd.*warncellid*.warnung*1-5*\n        prefix: string,\n        objNode: string, // the json path to object def for deepjson\n        def: statesObjectsType,\n        data: any,\n        expandTree: boolean = false,\n        onlyCreate: boolean = false,\n        isArray: boolean = false,\n    ): Promise<void> {\n        if (!def || typeof def !== 'object') {\n            return;\n        }\n        if (data === undefined || ['string', 'number', 'boolean', 'object'].indexOf(typeof data) == -1) {\n            return;\n        }\n\n        const objectDefinition = objNode ? this.getObjectDefFromJson(`${objNode}`, def, data) : null;\n\n        if (objectDefinition) {\n            objectDefinition.native = {\n                ...(objectDefinition.native || {}),\n                objectDefinitionReference: objNode,\n            };\n        }\n\n        if (typeof data === 'object' && data !== null) {\n            // handle array\n            if (Array.isArray(data)) {\n                if (!objectDefinition) {\n                    return;\n                }\n                if (data.length === 0) {\n                    return;\n                }\n                if (objectDefinition.type !== 'state' || expandTree) {\n                    const defChannel = this.getChannelObject(objectDefinition, prefix);\n                    //await this.writedp(prefix, null, defChannel);\n                    await this.writedp(prefix, null, { ...defChannel, native: { objnode: objNode } });\n                    for (let i = 0; i < data.length; i++) {\n                        const d = data[i];\n                        const dp = `${prefix}.${`00${i}`.slice(-2)}`;\n                        await this.writeFromJson(dp, `${objNode}`, def, d, expandTree, onlyCreate, true);\n                    }\n                } else {\n                    await this.writeFromJson(\n                        prefix,\n                        objNode,\n                        def,\n                        JSON.stringify(data) || '[]',\n                        expandTree,\n                        onlyCreate,\n                    );\n                }\n                //objectDefinition._id = `${this.adapter.name}.${this.adapter.instance}.${prefix}.${key}`;\n            } else {\n                if (Object.keys(data).length === 0) {\n                    return;\n                }\n                // create folder\n                if (objectDefinition) {\n                    const defChannel = this.getChannelObject(objectDefinition, prefix, isArray);\n\n                    // if data is from a array and there is a key title, we need to set the title to the folder name.\n                    // we need to set the extendedFolderAlways to true, to write the name this time.\n                    const valbefore = this.extendedFolderAlways;\n                    if (isArray && 'title' in data && data.title) {\n                        this.extendedFolderAlways = true;\n                        defChannel.common.name = data.title;\n                    }\n\n                    await this.writedp(prefix, null, { ...defChannel, native: { objnode: objNode } });\n\n                    // reset the extendedFolderAlways to the old value\n                    this.extendedFolderAlways = valbefore;\n                }\n                if (data === null) {\n                    return;\n                }\n\n                for (const k in data) {\n                    await this.writeFromJson(`${prefix}.${k}`, `${objNode}.${k}`, def, data[k], expandTree, onlyCreate);\n                }\n            }\n        } else {\n            if (!objectDefinition) {\n                return;\n            }\n            await this.writedp(prefix, data, { ...objectDefinition, native: { objnode: objNode } }, true, onlyCreate);\n        }\n    }\n\n    /**\n     * Get the ioBroker.Object out of stateDefinition\n     *\n     * @param key is the deep linking key to the definition\n     * @param def is the definition object\n     * @param data  is the definition dataset\n     * @returns ioBroker.ChannelObject | ioBroker.DeviceObject | ioBroker.StateObject\n     */\n    getObjectDefFromJson(\n        key: string,\n        def: any,\n        data: any,\n    ): ioBroker.ChannelObject | ioBroker.StateObject | ioBroker.DeviceObject | ioBroker.FolderObject {\n        let result = this.deepJsonValue(key, def);\n        if (result === null || result === undefined) {\n            const k = key.split('.');\n            if (k && k[k.length - 1].startsWith('_')) {\n                result = genericStateObjects.customString;\n                result = this.cloneObject(result);\n            } else {\n                // if no definition found, create a default one and dont log it\n                // name is the last part of the key\n                // incoming data is here to much mixed up, so we need to check the type\n\n                /*if (!key.includes('effects.')) {\n                    this.log.debug(`No definition for ${key}!`);\n                }*/\n\n                result = genericStateObjects.default;\n                result = this.cloneObject(result);\n                result.common.name = key.split('.').pop();\n                switch (typeof data) {\n                    case 'number':\n                    case 'bigint':\n                        {\n                            result.common.type = 'number';\n                            result.common.role = 'value';\n                        }\n                        break;\n                    case 'boolean':\n                        {\n                            result.common.type = 'boolean';\n                            result.common.role = 'indicator';\n                        }\n                        break;\n                    case 'string':\n                    case 'symbol':\n                    case 'undefined':\n                    case 'object':\n                    case 'function':\n                        {\n                            result.common.type = 'string';\n                            result.common.role = 'text';\n                        }\n                        break;\n                }\n            }\n        } else {\n            result = this.cloneObject(result);\n        }\n        return result;\n    }\n\n    /**\n     * Get a value from a deep json key\n     *\n     * @param key is the deep linking key to the definition\n     * @param data  is the definition dataset\n     * @returns any\n     */\n    deepJsonValue(key: string, data: any): any {\n        if (!key || !data || typeof data !== 'object' || typeof key !== 'string') {\n            throw new Error(`Error(222) data or key are missing/wrong type!`);\n        }\n        const k = key.split(`.`);\n        let c = 0,\n            s = data;\n        while (c < k.length) {\n            s = s[k[c++]];\n            if (s === undefined) {\n                return null;\n            }\n        }\n        return s;\n    }\n\n    /**\n     * Get a channel/device definition from property _channel out of a getObjectDefFromJson() result or a default definition.\n     *\n     * @param definition the definition object.\n     * @param id the id of the object\n     * @param tryArray try to get the array definition\n     * @returns ioBroker.ChannelObject | ioBroker.DeviceObject or a default channel obj\n     */\n    getChannelObject(\n        definition:\n            | (ioBroker.Object & {\n                  _channel?: ioBroker.Object;\n                  _array?: ioBroker.Object;\n              })\n            | null = null,\n        id: string = '',\n        tryArray: boolean = false,\n    ): ioBroker.ChannelObject | ioBroker.DeviceObject | ioBroker.FolderObject {\n        const def =\n            tryArray === true\n                ? (definition && definition._array) || (definition && definition._channel) || null\n                : (definition && definition._channel) || null;\n\n        const result: ioBroker.ChannelObject | ioBroker.DeviceObject | ioBroker.FolderObject = {\n            _id: def ? def._id : '',\n            type: def && def.type === 'device' ? 'device' : def && def.type === 'channel' ? 'channel' : 'folder',\n            common: {\n                name:\n                    def && def.common && def.common.name\n                        ? def.common.name\n                        : id && id.split('.').length > 2\n                          ? id.split('.').pop() || 'no definition'\n                          : 'no definition',\n            },\n            native: (def && def.native) || {},\n        };\n        return result;\n    }\n\n    /**\n     * Write/Create the specified data point with value, will only be written if val != oldval and obj.type == state or the data point value in the DB is not undefined. Channel and Devices have an undefined value.\n     *\n     * @param dp Data point to be written. Library.clean() is called with it.\n     * @param val Value for this data point. Channel vals (old and new) are undefined so they never will be written.\n     * @param obj The object definition for this data point (ioBroker.ChannelObject | ioBroker.DeviceObject | ioBroker.StateObject)\n     * @param ack set ack to false if needed - NEVER after u subscript to states)\n     * @param onlyCreate only extended the objects, do not write the values in exists states\n     * @param forceExtend force the extend of the object\n     * @param forceWrite force the write of the state even if val == oldval\n     * @returns void\n     */\n    async writedp(\n        dp: string,\n        val: ioBroker.StateValue | undefined,\n        obj:\n            | ioBroker.ChannelObject\n            | ioBroker.StateObject\n            | ioBroker.DeviceObject\n            | ioBroker.FolderObject\n            | null = null,\n        ack: boolean = true,\n        onlyCreate: boolean = false,\n        forceExtend: boolean = false,\n        forceWrite: boolean = false,\n    ): Promise<void> {\n        dp = this.cleandp(dp);\n        let node = this.readdb(dp);\n        let nodeIsNew = false;\n\n        if (node === undefined) {\n            if (!obj) {\n                throw new Error('writedp try to create a state without object informations.');\n            }\n            nodeIsNew = true;\n            obj._id = `${this.adapter.name}.${this.adapter.instance}.${dp}`;\n            if (typeof obj.common.name == 'string') {\n                obj.common.name = await this.getTranslationObj(obj.common.name);\n            }\n            if (typeof obj.common.desc == 'string') {\n                obj.common.desc = await this.getTranslationObj(obj.common.desc);\n            }\n\n            await this.adapter.extendObject(dp, obj);\n\n            const stateType = obj && obj.common && 'type' in obj.common && obj.common.type;\n            node = this.setdb(dp, obj.type, undefined, stateType, true, Date.now(), obj);\n        } else if ((node.init || this.extendedFolderAlways || forceExtend) && obj) {\n            if (typeof obj.common.name == 'string') {\n                obj.common.name = await this.getTranslationObj(obj.common.name);\n            }\n            if (typeof obj.common.desc == 'string') {\n                obj.common.desc = await this.getTranslationObj(obj.common.desc);\n            }\n\n            await this.adapter.extendObject(dp, obj);\n        }\n\n        if ((obj && obj.type !== 'state') || (onlyCreate && !nodeIsNew)) {\n            return;\n        }\n\n        if (node) {\n            this.setdb(dp, node.type, val, node.stateTyp, true);\n        }\n\n        if (node && (!this.defaults.updateStateOnChangeOnly || forceWrite || node.val !== val || !node.ack)) {\n            const typ = (obj && obj.common && obj.common.type) || node.stateTyp;\n            if (typ && typ != typeof val && val !== undefined) {\n                val = this.convertToType(val, typ);\n            }\n\n            await this.adapter.setState(dp, {\n                val: val,\n                ts: Date.now(),\n                ack: ack,\n            });\n        }\n    }\n\n    /**\n     * Get the states that match the specified string.\n     *\n     * @param str The string to match.\n     * @returns The states that match the specified string.\n     */\n    getStates(str: string): { [key: string]: LibraryStateVal } {\n        const result: { [key: string]: LibraryStateVal } = {};\n        for (const dp in this.stateDataBase) {\n            if (this.stateDataBase[dp] && dp.search(new RegExp(str, 'g')) != -1) {\n                result[dp] = this.stateDataBase[dp];\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get the states that match the specified string.\n     *\n     * @param hold The string to hold.\n     * @param filter The string to filter.\n     * @param deep The number of deep.\n     */\n    async cleanUpTree(hold: string[], filter: string[] | null, deep: number): Promise<void> {\n        let del = [];\n        for (const dp in this.stateDataBase) {\n            if (filter && filter.filter(a => dp.startsWith(a) || a.startsWith(dp)).length == 0) {\n                continue;\n            }\n            if (hold.filter(a => dp.startsWith(a) || a.startsWith(dp)).length > 0) {\n                continue;\n            }\n            delete this.stateDataBase[dp];\n            del.push(dp.split('.').slice(0, deep).join('.'));\n        }\n        del = del.filter((item, pos, arr) => {\n            return arr.indexOf(item) == pos;\n        });\n        for (const d of del) {\n            await this.adapter.delObjectAsync(d, { recursive: true });\n            this.log.debug(`Clean up tree delete: ${d}`);\n        }\n    }\n\n    /**\n     * Remove forbidden chars from datapoint string.\n     *\n     * @param string Datapoint string to clean\n     * @param lowerCase lowerCase() first param.\n     * @param removePoints remove . from dp\n     * @returns void\n     */\n    cleandp(string: string, lowerCase: boolean = false, removePoints: boolean = false): string {\n        if (!string && typeof string != 'string') {\n            return string;\n        }\n\n        string = string.replace(this.adapter.FORBIDDEN_CHARS, '_');\n        // hardliner\n        if (removePoints) {\n            string = string.replace(/[^0-9A-Za-z_-]/gu, '_');\n        } else {\n            string = string.replace(/[^0-9A-Za-z._-]/gu, '_');\n        }\n        return lowerCase ? string.toLowerCase() : string;\n    }\n\n    /**\n     * Convert a value to the given type\n     *\n     * @param value \tthen value to convert\n     * @param type the target type\n     * @returns the converted value\n     */\n    convertToType(value: ioBroker.StateValue | Array<any> | JSON, type: string): ioBroker.StateValue {\n        if (value === null) {\n            return null;\n        }\n        if (type === undefined) {\n            throw new Error('convertToType type undefined not allowed!');\n        }\n        if (value === undefined) {\n            value = '';\n        }\n\n        const old_type = typeof value;\n        let newValue: ioBroker.StateValue = typeof value == 'object' ? JSON.stringify(value) : value;\n\n        if (type !== old_type) {\n            switch (type) {\n                case 'string':\n                    newValue = (value as string).toString() || '';\n                    break;\n                case 'number':\n                    newValue = value ? parseFloat(value as string) : 0;\n                    break;\n                case 'boolean':\n                    newValue = !!value;\n                    break;\n                case 'array':\n                case 'json':\n                    //JSON.stringify() is done before\n                    break;\n            }\n        }\n        return newValue;\n    }\n    /**\n     * Read the state from the database.\n     *\n     * @param dp The data point to read.\n     */\n    readdb(dp: string): LibraryStateVal {\n        return this.stateDataBase[this.cleandp(dp)];\n    }\n    /**\n     * Set the state in the database.\n     *\n     * @param dp The data point to set.\n     * @param type The type of the data point.\n     * @param val The value of the data point.\n     * @param stateType The state type of the data point.\n     * @param ack The ack of the data point.\n     * @param ts The timestamp of the data point.\n     * @param obj The object of the data point.\n     * @param init The init of the data point.\n     * @returns The state in the database.\n     */\n    setdb(\n        dp: string,\n        type: ioBroker.ObjectType | LibraryStateVal,\n        val: ioBroker.StateValue | undefined = undefined,\n        stateType: string | undefined = undefined,\n        ack: boolean = true,\n        ts: number = Date.now(),\n        obj: ioBroker.Object | undefined = undefined,\n        init: boolean = false,\n    ): LibraryStateVal {\n        if (typeof type == 'object') {\n            type = type as LibraryStateVal;\n            this.stateDataBase[dp] = type;\n        } else {\n            type = type as ioBroker.ObjectType;\n            this.stateDataBase[dp] = {\n                type: type,\n                stateTyp:\n                    stateType !== undefined\n                        ? stateType\n                        : this.stateDataBase[dp] !== undefined && this.stateDataBase[dp].stateTyp !== undefined\n                          ? this.stateDataBase[dp].stateTyp\n                          : undefined,\n                val: val,\n                ack: ack,\n                ts: ts ? ts : Date.now(),\n                obj:\n                    obj !== undefined\n                        ? obj\n                        : this.stateDataBase[dp] !== undefined && this.stateDataBase[dp].obj !== undefined\n                          ? this.stateDataBase[dp].obj\n                          : undefined,\n                init: init,\n            };\n        }\n        return this.stateDataBase[dp];\n    }\n    /**\n     * Delete the state from the database.\n     *\n     * @param data The data point to delete.\n     */\n    async memberDeleteAsync(data: any[]): Promise<void> {\n        for (const d of data) {\n            await d.delete();\n        }\n    }\n    /**\n     * Clone an object.\n     *\n     * @param obj The object to clone.\n     */\n    cloneObject(obj: ioBroker.Object): ioBroker.Object {\n        if (typeof obj !== 'object') {\n            this.log.error(`Error clone object target is type: ${typeof obj}`);\n            return obj;\n        }\n        return JSON.parse(JSON.stringify(obj));\n    }\n    /**\n     * Clone a generic object.\n     *\n     * @param obj The object to clone.\n     */\n    cloneGenericObject(obj: object): object {\n        if (typeof obj !== 'object') {\n            this.log.error(`Error clone object target is type: ${typeof obj}`);\n            return obj;\n        }\n        return JSON.parse(JSON.stringify(obj));\n    }\n    /**\n     * Check if a file exists.\n     *\n     * @param file The file to check.\n     */\n    fileExistAsync(file: string): boolean {\n        if (_fs.existsSync(`./admin/${file}`)) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Initialise the database with the states to prevent unnecessary creation and writing.\n     *\n     * @param states States that are to be read into the database during initialisation.\n     * @returns void\n     */\n    async initStates(states: {\n        [key: string]: {\n            /**\n             * The value of the state.\n             */\n            val: ioBroker.StateValue;\n            /**\n             * The timestamp of the state.\n             */\n            ts: number;\n            ack: boolean;\n        };\n    }): Promise<void> {\n        if (!states) {\n            return;\n        }\n        this.stateDataBase = {};\n        for (const state in states) {\n            const dp = state.replace(`${this.adapter.name}.${this.adapter.instance}.`, '');\n\n            const obj = await this.adapter.getObjectAsync(dp);\n            this.setdb(\n                dp,\n                'state',\n                states[state] && states[state].val ? states[state].val : undefined,\n                obj && obj.common && obj.common.type ? obj.common.type : undefined,\n                states[state] && states[state].ack,\n                states[state] && states[state].ts ? states[state].ts : Date.now(),\n                obj == null ? undefined : obj,\n                true,\n            );\n        }\n    }\n\n    /**\n     * Clean up the database.\n     *\n     * @param prefix The prefix to clean up.\n     * @param offset The offset to clean up.\n     * @param del Whether to delete the data point. this part need rework\n     */\n    async garbageColleting(prefix: string, offset: number = 2000, del = false): Promise<void> {\n        if (!prefix || !this.stateDataBase) {\n            return;\n        }\n        if (del) {\n            this.log.warn(`garbageColleting with del = true is not well implemented yet!`);\n            return;\n        }\n\n        const filteredStateKeys = Object.keys(this.stateDataBase).filter(id => id.startsWith(prefix));\n        const currentTestTime = Date.now() - offset;\n        for (const id of filteredStateKeys) {\n            const state = this.stateDataBase[id];\n            if (!state) {\n                continue;\n            }\n            if (state.val === undefined && (!state.obj || state.obj.type !== 'state' || !state.stateTyp)) {\n                if (state.obj && state.obj.common && state.obj.common.def) {\n                    state.ts = 1;\n                } else {\n                    continue;\n                }\n            }\n            if (state.ts < currentTestTime) {\n                if (del) {\n                    await this.cleanUpTree([], [id], -1);\n                    continue;\n                }\n                let newVal: -1 | '' | '{}' | '[]' | false | null | undefined;\n                if (state.obj && state.obj.common && state.obj.common.def) {\n                    newVal = state.obj.common.def;\n                } else {\n                    switch (state.stateTyp || (state.obj && state.obj.common && state.obj.common.type) || 'string') {\n                        case 'string':\n                            if (typeof state.val == 'string') {\n                                if (state.val.startsWith('{') && state.val.endsWith('}')) {\n                                    newVal = '{}';\n                                } else if (state.val.startsWith('[') && state.val.endsWith(']')) {\n                                    newVal = '[]';\n                                } else {\n                                    newVal = '';\n                                }\n                            } else {\n                                newVal = '';\n                            }\n                            break;\n                        case 'bigint':\n                        case 'number':\n                            newVal = -1;\n                            break;\n\n                        case 'boolean':\n                            newVal = false;\n                            break;\n                        case 'symbol':\n                        case 'object':\n                        case 'function':\n                            newVal = null;\n                            break;\n                        case 'undefined':\n                            newVal = undefined;\n                            break;\n                    }\n                }\n                await this.writedp(id, newVal);\n            }\n        }\n    }\n    /**\n     * Get the local language\n     *\n     * @returns string\n     */\n    getLocalLanguage(): string {\n        if (this.language) {\n            return this.language;\n        }\n        return 'en-En';\n    }\n    /**\n     * Get the translation for the specified key.\n     *\n     * @param key The key to get the translation for.\n     */\n    getTranslation(key: string): string {\n        if (this.translation[key] !== undefined) {\n            return this.translation[key];\n        }\n        return key;\n    }\n    /**\n     * Check if a translation exists for the specified key.\n     *\n     * @param key The key to check.\n     */\n    existTranslation(key: string): boolean {\n        return this.translation[key] !== undefined;\n    }\n    /**\n     * Get the translation object for the specified key.\n     *\n     * @param key The key to get the translation object for.\n     */\n    async getTranslationObj(key: string): Promise<ioBroker.StringOrTranslated> {\n        const language: (ioBroker.Languages | 'uk')[] = [\n            'en',\n            'de',\n            'ru',\n            'pt',\n            'nl',\n            'fr',\n            'it',\n            'es',\n            'pl',\n            'uk',\n            'zh-cn',\n        ];\n        const result: { [key: string]: string } = {};\n        for (const l of language) {\n            try {\n                const i = await import(`../../admin/i18n/${l}/translations.json`);\n                if (i[key] !== undefined) {\n                    result[l as string] = i[key];\n                }\n            } catch {\n                return key;\n            }\n        }\n        if (result.en == undefined) {\n            return key;\n        }\n        return result as ioBroker.StringOrTranslated;\n    }\n    /**\n     * Set the language for the library.\n     *\n     * @param language The language to set.\n     * @param force Whether to force the language.\n     */\n    async setLanguage(language: ioBroker.Languages | 'uk', force = false): Promise<boolean> {\n        if (!language) {\n            language = 'en';\n        }\n        if (force || this.language != language) {\n            try {\n                this.translation = await import(`../../admin/i18n/${language}/translations.json`);\n                this.language = language;\n                return true;\n            } catch {\n                this.log.error(`Language ${language} not exist!`);\n            }\n        }\n        return false;\n    }\n    /**\n     * Get the language for the library.\n     *\n     * @param text The text to translate.\n     * @returns The translated text.\n     */\n    sortText(text: string[]): string[] {\n        text.sort((a, b) => {\n            const nameA = a.toUpperCase(); // ignore upper and lowercase\n            const nameB = b.toUpperCase(); // ignore upper and lowercase\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n\n            return 0;\n        });\n        return text;\n    }\n    /**\n     *\n     * @param text string to replace a Date\n     * @param noti appendix to translation key\n     * @param day true = Mo, 12.05 - false = 12.05\n     * @returns Monday first March\n     */\n    convertSpeakDate(text: string, noti: string = '', day = false): string {\n        if (!text || typeof text !== `string`) {\n            return ``;\n        }\n        const b = text.split(`.`);\n        if (day) {\n            b[0] = b[0].split(' ')[2];\n        }\n        return ` ${`${new Date(`${b[1]}/${b[0]}/${new Date().getFullYear()}`).toLocaleString(this.language, {\n            weekday: day ? 'long' : undefined,\n            day: 'numeric',\n            month: `long`,\n        })} `.replace(/([0-9]+\\.)/gu, x => {\n            const result = this.getTranslation(x + noti);\n            if (result != x + noti) {\n                return result;\n            }\n            return this.getTranslation(x);\n        })}`;\n    }\n}\n"],
  "mappings": "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",
  "names": ["_fs"]
}
